Description: fix autopkgtest for python3
 There are some python3 incompatibilities left in autotest_runner.py
 - encoding on check_output
 - StringIO
Forwarded: no
X-Not-Forwarded-Reason: experimental
Author: Christian Ehrhardt <christian.ehrhardt@canonical.com>
Last-Update: 2020-05-05
--- a/app/test/autotest_runner.py
+++ b/app/test/autotest_runner.py
@@ -4,7 +4,7 @@
 # The main logic behind running autotests in parallel
 
 from __future__ import print_function
-import StringIO
+import io
 import csv
 from multiprocessing import Pool, Queue
 import pexpect
@@ -45,11 +45,9 @@ def get_numa_nodes():
 def first_cpu_on_node(node_nr):
     cpu_path = glob.glob("/sys/devices/system/node/node%d/cpu*" % node_nr)
     r = re.compile(r"cpu(\d+)")
-    cpu_name = filter(None,
-            map(r.match,
-                map(os.path.basename, cpu_path)
-            )
-    )
+    cpu_name = [_f for _f in map(r.match,
+                list(map(os.path.basename, cpu_path))
+            ) if _f]
     # for compatibility between python 3 and 2 we need to make interable out
     # of filter return as it returns list in python 2 and a generator in 3
     m = next(iter(cpu_name))
@@ -78,7 +76,7 @@ def pool_init(queue, result_queue):
     cmdline = "%s %s" % (cmdline, prefix_cmdline)
 
     # prepare logging of init
-    startuplog = StringIO.StringIO()
+    startuplog = io.StringIO()
 
     # run test app
     try:
@@ -138,7 +136,7 @@ def run_test(target, test):
     # create log buffer for each test
     # in multiprocessing environment, the logging would be
     # interleaved and will create a mess, hence the buffering
-    logfile = StringIO.StringIO()
+    logfile = io.StringIO()
     pool_child.logfile = logfile
 
     # make a note when the test started
@@ -210,7 +208,7 @@ class AutotestRunner:
         # parse the binary for available test commands
         binary = cmdline.split()[0]
         stripped = 'not stripped' not in \
-                   subprocess.check_output(['file', binary])
+                   subprocess.check_output(['file', binary]).decode('utf-8')
         if not stripped:
             symbols = subprocess.check_output(['nm', binary]).decode('utf-8')
             self.avail_cmds = re.findall('test_register_(\w+)', symbols)
